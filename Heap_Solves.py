# -*- coding: utf-8 -*-
"""CSE220_Lab Assignment 7

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12wlv9BLlynpq194spEjvHAUcyEJFkvR7
"""

import numpy as np

class MinHeap:
    def __init__(self, capacity):
        self.__H = np.zeros(capacity+1, dtype=int)
        self.__size = 0

    def insert(self, key):
        if self.__size>=len(self.__H)-1:
            return "Heap is full."
        self.__size += 1
        self.__H[self.__size] = key
        self.swim(self.__size)

    def swim(self, index):
        if index <= 1:
            return
        else:
            parent = index//2
            if self.__H[parent]>self.__H[index]:
                self.__H[index], self.__H[parent] = self.__H[parent], self.__H[index]
                self.swim(parent)

    def extractMin(self):
        if self.__size==0:
            return "Heap is empty."
        min_val = self.__H[1]
        self.__H[1] = self.__H[self.__size]
        self.__size -= 1
        self.sink(1)

        return min_val

    def sink(self, index):
        if self.__size==0:
            return
        else:
            left = 2*index
            right = 2*index+1
            parent = index
            if left<=self.__size and right<=self.__size:
                if self.__H[parent]>self.__H[left] or self.__H[parent]>self.__H[right]:
                    if self.__H[left]<self.__H[right]:
                        min_child = left
                    else:
                        min_child = right
                    self.__H[parent], self.__H[min_child] = self.__H[min_child], self.__H[parent]
                    self.sink(min_child)
            elif left<=self.__size and right>self.__size:
                if self.__H[parent]>self.__H[left]:
                    self.__H[parent], self.__H[left] = self.__H[left], self.__H[parent]

    def sort(self):
        sorted = np.zeros(self.__size+1, dtype=int)

        for i in range(1, self.__size+1):
            sorted[i] = self.extractMin()

        return sorted

min_heap = MinHeap(5)
arr = [5, 3, 8, 1, 2]

for i in arr:
    min_heap.insert(i)

print("Extracted min:", min_heap.extractMin())
sorted_elements = min_heap.sort()
print("Sorted elements:", sorted_elements)

class MaxHeap:
    def __init__(self, capacity):
        self.__H = np.zeros(capacity+1, dtype=int)
        self.__size = 0

    def insert(self, key):
        if self.__size>=len(self.__H)-1:
            return "Heap is full."
        self.__size += 1
        self.__H[self.__size] = key
        self.swim(self.__size)

    def swim(self, index):
        if index <= 1:
            return
        else:
            parent = index//2
            if self.__H[parent]<self.__H[index]:
                self.__H[index], self.__H[parent] = self.__H[parent], self.__H[index]
                self.swim(parent)

    def extractMax(self):
        if self.__size==0:
            return "Heap is empty."
        min_val = self.__H[1]
        self.__H[1] = self.__H[self.__size]
        self.__size -= 1
        self.sink(1)

        return min_val

    def sink(self, index):
        if self.__size==0:
            return
        else:
            left = 2*index
            right = 2*index+1
            parent = index
            if left<=self.__size and right<=self.__size:
                if self.__H[parent]<self.__H[left] or self.__H[parent]<self.__H[right]:
                    if self.__H[left]>self.__H[right]:
                        max_child = left
                    else:
                        max_child = right
                    self.__H[parent], self.__H[max_child] = self.__H[max_child], self.__H[parent]
                    self.sink(max_child)
            elif left<=self.__size and right>self.__size:
                if self.__H[parent]<self.__H[left]:
                    self.__H[parent], self.__H[left] = self.__H[left], self.__H[parent]

    def sort(self):
        sorted = np.zeros(self.__size+1, dtype=int)

        for i in range(1, self.__size+1):
            sorted[i] = self.extractMax()

        return sorted

max_heap = MaxHeap(5)
arr = [5, 3, 8, 1, 2]

for i in arr:
    max_heap.insert(i)

print("Extracted max:", max_heap.extractMax())
sorted_elements = max_heap.sort()
print("Sorted elements:", sorted_elements)

def distribute(tasks, m):
    result = np.zeros(m, dtype=int)
    min_heap = MinHeap(m)
    for i in range(m):
        min_heap.insert(0)
    for j in tasks:
        load = min_heap.extractMin() + j
        min_heap.insert(load)
    for k in range(m):
        result[k] = min_heap.extractMin()
    return result

tasks = np.array([2, 4, 7, 1, 6])
m = 4
print(distribute(tasks, m))

def largest(nums, k):
    max_heap = MaxHeap(len(nums))
    result = np.zeros(k, dtype=int)
    for i in nums:
        max_heap.insert(i)
    for j in range(k):
        result[j] = max_heap.extractMax()
    return result

nums = np.array([4, 10, 2, 8, 6, 7])
k = 3
print(largest(nums, k))