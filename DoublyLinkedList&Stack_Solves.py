# -*- coding: utf-8 -*-
"""CSE220_Lab Assignment 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W0y_WQj5LT6C8aqchgXM5KUtAlIxrto9
"""

# You must run this cell to install dependency
! pip3 install fhm-unittest
! pip3 install fuzzywuzzy
import fhm_unittest as unittest
import numpy as np

"""**Assignment Part 1: Doubly Linked List**

For Assignment Part 1, you should write your full code in the following cells along with your driver codes on your own.
"""

#Assignment Part 1

class Patient:
  #write a constructor
  def __init__(self, id, name, age, bloodgroup, next, prev):
    self.id = id
    self.name = name
    self.age = age
    self.bloodgroup = bloodgroup
    self.next = next
    self.prev = prev

class WRM:

  def __init__(self):
    #Creating the dummy head
    self.dh = Patient(None,None,None,None,None,None)
    self.dh.next = self.dh
    self.dh.prev = self.dh

  def registerPatient(self,id, name, age, bloodgroup):
    self.patient = Patient(id, name, age, bloodgroup)
    tail = self.dh.prev
    tail.next = new_patient
    new_patient.prev = tail
    new_patient.next = self.dh
    self.dh.prev = new_patient
    print("Patient registered successfully.")
    #To Do

  def servePatient(self):
    if self.dh.next==self.dh:
        print("No patients to serve.")
    first = self.dh.next
    print(f"Serving {first.name}")
    self.dh.next = first.next
    first.next.prev = self.dh
    #To Do

  def showAllPatient(self):
    if self.dh.next==self.dh:
        print("No patients in the waiting room.")
    temp = self.dh.next
    print("Patient's IDs: ")
    while temp:
        print(temp.id)
        temp = temp.next
    #To Do

  def canDoctorGoHome(self):
    if self.dh.next==self.dh:
        return "Yes"
    return "No"
    #To Do

  def cancelAll(self):
    self.dh.next = self.dh
    self.dh.prev = self.dh
    print("All appointments are cancelled.")
    #To Do

  def ReverseTheLine(self):
    temp = self.dh.next
    last = None
    while temp:
        next_patient = temp.next
        temp.next = last
        last = temp
        temp = next_patient
    last.prev = self.dh
    last.next = self.dh.next
    self.dh.next.prev = last
    self.dh.next = last
    #To Do

#Write a Tester Code in this cell
print("**Welcome to Waiting Room Management System**")
id = int(input("Enter ID: "))
name = input("Enter Name: ")
age = int(input("Enter Age: "))
bloodgroup = input("Enter Blood Group: ")
wrm_system.registerPatient(id, name, age, bloodgroup)
wrm_system.servePatient()
wrm_system.showAllPatient()
wrm_system.canDoctorGoHome()
wrm_system.cancelAll()
wrm_system.reverseTheLine()

"""**Assignment Part 2: Stack**

Linked List based Stack is implemented in the following cell.
"""

class Node:
  def __init__(self,elem=None,next=None):
    self.elem = elem
    self.next = next

class Stack:
  def __init__(self):
    self.__top = None

  def push(self,elem):
    nn = Node(elem,self.__top)
    self.__top = nn

  def pop(self):
    if self.__top == None:
      #print('Stack Underflow')
      return None
    e = self.__top
    self.__top = self.__top.next
    return e.elem

  def peek(self):
    if self.__top == None:
      #print('Stack Underflow')
      return None
    return self.__top.elem

  def isEmpty(self):
    return self.__top == None

#You can run this driver code cell to understand the methods of Stack class
st = Stack()
st.push(4)
st.push(3)
st.push(5)
st.push(1)
st.push(9)

print('Peeked Element: ',st.peek())
print('Popped Element: ',st.pop())
print('Popped Element: ',st.pop())
print('Popped Element: ',st.pop())
print('Peeked Element: ',st.peek())
print('Popped Element: ',st.pop())
print('Popped Element: ',st.pop())
print('Peeked Element: ',st.peek())
print('Popped Element: ',st.pop())
print(st.isEmpty())

"""You can print your stack using this code segment"""

def print_stack(st):
  if st.isEmpty():
    return
  p = st.pop()
  print('|',p,end=' ')
  if p<10:
    print(' |')
  else:
    print('|')
  #print('------')
  print_stack(st)
  st.push(p)

# st = Stack()
# st.push(4)
# st.push(3)
# st.push(5)
# st.push(1)
# st.push(9)
# print_stack(st)
# print('------')

"""Task 1: Diamond Count"""

def diamond_count(stack,string):
    diamond = 0
    for i in range(len(string)):
        if string[i]=="<":
            stack.push(string[i])
        elif string[i]==">" and not stack.isEmpty():
            stack.pop()
            diamond += 1
    return diamond

  #TO DO



print('Test 01')
stack = Stack()
string = '<..><.<..>> '
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 3
unittest.output_test(returned_value, 3)
print('-----------------------------------------')


print('Test 02')
stack = Stack()
string = '<<<..<......<<<<....>'
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 1
unittest.output_test(returned_value, 1)
print('-----------------------------------------')


print('Test 03')
stack = Stack()
string = '>>><...<<..>>...>...>>>'
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 3
unittest.output_test(returned_value, 3)
print('-----------------------------------------')

"""Task 2: Tower of Blocks"""

def remove_block(stack, n):
    st = Stack()
    for i in range(n-1):
        num = stack.pop()
        st.push(num)
    stack.pop()
    for i in range(n-1):
        n = st.pop()
        stack.push(n)
    return stack

  #TO DO


print('Test 01')
st = Stack()
st.push(4)
st.push(19)
st.push(23)
st.push(17)
st.push(5)
print('Stack:')
print_stack(st)
print('------')
remove_block(st,2)
print('After Removal')
print_stack(st)
print('------')

print()
print('======================================')
print()

print('Test 02')
st = Stack()
st.push(73)
st.push(85)
st.push(15)
st.push(41)
print('Stack:')
print_stack(st)
print('------')
remove_block(st,3)
print('After Removal')
print_stack(st)
print('------')

print()
print('======================================')
print()

"""Task 3: Stack Reverse"""

def conditional_reverse(stack):
    st = Stack()
    while not stack.isEmpty():
        num = stack.pop()
        if num!=st.peek():
            st.push(num)
    return st

  #To Do


print('Test 01')
st=Stack()
st.push(10)
st.push(10)
st.push(20)
st.push(20)
st.push(30)
st.push(10)
st.push(50)
print('Stack:')
print_stack(st)
print('------')
reversed_stack=conditional_reverse(st)
print('Conditional Reversed Stack:')
print_stack(reversed_stack) # This stack contains 50, 10, 30, 20, 10 in this order whereas top element should be 10
print('------')